import io.github.resilience4j.retry.RetryRegistry;
import io.github.resilience4j.retry.RetryConfig;
import io.github.resilience4j.retry.Retry;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;

import java.util.concurrent.atomic.AtomicInteger;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

@SpringBootTest
class MyServiceTest {

    @MockBean
    private MyService myService;

    @Autowired
    private RetryRegistry retryRegistry;

    private Retry retry;

    @BeforeEach
    void setUp() {
        retry = retryRegistry.retry("myServiceRetry");
    }

    @Test
    void testRetrySuccessAfterFailure() {
        // Mock the unstableMethod to fail twice, then succeed
        AtomicInteger invocationCounter = new AtomicInteger(0);
        when(myService.unstableMethod()).thenAnswer(invocation -> {
            if (invocationCounter.incrementAndGet() < 3) {
                throw new RuntimeException("Simulated failure");
            }
            return "Success!";
        });

        // Call the method
        String result = myService.unstableMethod();

        // Verify the result
        assertEquals("Success!", result);

        // Verify the number of attempts
        verify(myService, times(3)).unstableMethod();
    }

    @Test
    void testRetryFallbackAfterMaxAttempts() {
        // Mock the unstableMethod to always fail
        when(myService.unstableMethod()).thenThrow(new RuntimeException("Simulated failure"));

        // Call the method and expect the fallback
        String result = null;
        try {
            result = myService.unstableMethod();
        } catch (RuntimeException ignored) {
        }

        // Verify the fallback is triggered
        assertEquals(null, result);

        // Verify the number of attempts
        verify(myService, times(retryTimes)).unstableMethod();
    }
}
